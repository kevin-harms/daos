#!/usr/bin/python
'''
  (C) Copyright 2018 Intel Corporation.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

  GOVERNMENT LICENSE RIGHTS-OPEN SOURCE SOFTWARE
  The Government's rights to use, modify, reproduce, release, perform, display,
  or disclose this software are subject to the terms of the Apache License as
  provided in Contract No. B609815.
  Any reproduction of computer software, computer software documentation, or
  portions thereof marked with this legend must also reproduce the markings.
'''
import os
import time
import traceback
import sys
import json
from apricot import Test
from avocado import main


import ServerUtils
import WriteHostFile
from conversion import c_uuid_to_str
from daos_api import DaosContext, DaosPool, DaosContainer, DaosApiError

class BasicEpochTest(Test):
    """
    A very simple test verifying the use of epochs.
    :avocado: recursive
    """
    def setUp(self):

        # get paths from the build_vars generated by build
        with open('../../../.build_vars.json') as f:
            build_paths = json.load(f)
        self.basepath = os.path.normpath(build_paths['PREFIX']  + "/../")
        self.tmp = build_paths['PREFIX'] + '/tmp'

        self.server_group = self.params.get("server_group",'/server/',
                                           'daos_server')

        # setup the DAOS python API
        self.Context = DaosContext(build_paths['PREFIX'] + '/lib/')

        self.hostlist = self.params.get("test_machines",'/run/hosts/*')
        self.hostfile = WriteHostFile.WriteHostFile(self.hostlist, self.tmp)

        ServerUtils.runServer(self.hostfile, self.server_group, self.basepath)

        # give it time to start
        time.sleep(2)

    def tearDown(self):
        try:
            if self.hostfile is not None:
                os.remove(self.hostfile)
        finally:
            ServerUtils.stopServer(hosts=self.hostlist)

    def test_epoch_basics(self):
        """
        Perform I/O to an object in a container in 2 different epochs,
        verifying basic I/O and epochs in particular.

        :avocado: tags=container,epoch,basicepoch
        """
        try:
            # parameters used in pool create
            createmode = self.params.get("mode",'/run/conttests/createmode/')
            createuid  = self.params.get("uid",'/run/conttests/createuid/')
            creategid  = self.params.get("gid",'/run/conttests/creategid/')
            createsetid = self.params.get("setname",'/run/conttests/createset/')
            createsize  = self.params.get("size",'/run/conttests/createsize/')

            # initialize a python pool object then create the underlying
            # daos storage
            POOL = DaosPool(self.Context)
            POOL.create(createmode, createuid, creategid,
                        createsize, createsetid, None)

            # need a connection to create container
            POOL.connect(1 << 1)

            # create a container
            CONTAINER = DaosContainer(self.Context)
            CONTAINER.create(POOL.handle)

            # now open it
            CONTAINER.open()

            # do a query and compare the UUID returned from create with
            # that returned by query
            CONTAINER.query()

            if CONTAINER.get_uuid_str() != c_uuid_to_str(
                    CONTAINER.info.ci_uuid):
                self.fail("Container UUID did not match the one in info\n")

            # create an object and write some data into it
            thedata = "a string that I want to stuff into an object"
            thedatasize = 45
            dkey = "this is the dkey"
            akey = "this is the akey"

            oid, epoch = CONTAINER.write_an_obj(thedata, thedatasize,
                                                dkey, akey)

            # read the data back and make sure its correct
            thedata2 = CONTAINER.read_an_obj(thedatasize, dkey, akey,
                                             oid, epoch)
            if thedata != thedata2.value:
                print("thedata>" + thedata)
                print("thedata2>" + thedata2.value)
                self.fail("Write data 1, read it back, didn't match\n")

            # repeat above, but know that the write_an_obj call is advancing
            # the epoch so the original copy remains and the new copy is in
            # a new epoch.
            thedata3 = "a different string"
            thedatasize2 = 19
            # note using the same keys so writing to the same spot
            dkey = "this is the dkey"
            akey = "this is the akey"

            oid, epoch2 = CONTAINER.write_an_obj(thedata3, thedatasize2,
                                                 dkey, akey, oid)

            # read the data back and make sure its correct
            thedata4 = CONTAINER.read_an_obj(thedatasize2, dkey, akey,
                                             oid, epoch2)
            if thedata3 != thedata4.value:
                self.fail("Write data 2, read it back, didn't match\n")

            # the original data should still be there too
            thedata5 = CONTAINER.read_an_obj(thedatasize, dkey, akey,
                                             oid, epoch)
            if thedata != thedata5.value:
                self.fail("Write data 3, read it back, didn't match\n")

            CONTAINER.close()

            # wait a few seconds and then destroy
            time.sleep(5)
            CONTAINER.destroy()

            # cleanup the pool
            POOL.disconnect()
            POOL.destroy(1)

        except DaosApiError as e:
            print(e)
            print(traceback.format_exc())
            self.fail("Test was expected to pass but it failed.\n")

if __name__ == "__main__":
    main()
